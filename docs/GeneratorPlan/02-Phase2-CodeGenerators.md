# Phase 2: Code Generators (Weeks 2-3)

## Overview

Phase 2 implements all code generation logic - the core of the generator system. Each generator creates production-ready code from CSV metadata.

**Duration:** Weeks 2-3 (10 working days)

**Deliverables:**
- ✅ OrganizationTrait Generator (NEW in V4)
- ✅ Entity Generator (base + extension)
- ✅ API Platform YAML Generator
- ✅ Repository Generator (NEW: abstract layer pattern)
- ✅ Controller Generator (base + extension)
- ✅ Voter Generator (base + extension)
- ✅ Form Generator (base + extension)
- ✅ Unit tests for all generators (80%+ coverage)

---

## Day 1-2: OrganizationTrait Generator (NEW)

### File: `src/Service/Generator/Entity/OrganizationTraitGenerator.php`

**Purpose:** Generate the OrganizationTrait that provides multi-tenant functionality to entities.

**Key Features:**
- Generated ONCE (not regenerated on subsequent runs)
- Contains organization property with ManyToOne relationship
- Includes getter and setter methods
- Used by entities where `hasOrganization=true` in CSV

**Implementation:**

```php
<?php

declare(strict_types=1);

namespace App\Service\Generator\Entity;

use Symfony\Component\Filesystem\Filesystem;
use Twig\Environment;

class OrganizationTraitGenerator
{
    private const TRAIT_PATH = '/src/Entity/Trait/OrganizationTrait.php';

    public function __construct(
        private readonly string $projectDir,
        private readonly Environment $twig,
        private readonly Filesystem $filesystem
    ) {}

    /**
     * Generate OrganizationTrait if it doesn't exist
     */
    public function generate(): bool
    {
        $filePath = $this->projectDir . self::TRAIT_PATH;

        // Only generate if file doesn't exist
        if (file_exists($filePath)) {
            return false; // Already exists, skip
        }

        // Create directory if needed
        $dir = dirname($filePath);
        if (!is_dir($dir)) {
            $this->filesystem->mkdir($dir, 0755);
        }

        // Render trait from template
        $content = $this->twig->render('generator/php/organization_trait.php.twig');

        // Write file
        file_put_contents($filePath, $content);

        return true; // Generated
    }

    /**
     * Check if trait exists
     */
    public function exists(): bool
    {
        return file_exists($this->projectDir . self::TRAIT_PATH);
    }
}
```

**Twig Template:** `templates/generator/php/organization_trait.php.twig`

```php
<?php

declare(strict_types=1);

namespace App\Entity\Trait;

use App\Entity\Organization;
use Doctrine\ORM\Mapping as ORM;
use Symfony\Component\Serializer\Annotation\Groups;

/**
 * Organization Trait
 * Provides multi-tenant organization support for entities
 *
 * This trait is generated ONCE and should NOT be modified by the generator
 * afterwards. It can be safely edited for custom business logic.
 *
 * @generated by Luminai Code Generator
 * @see /config/Entity.csv for configuration
 */
trait OrganizationTrait
{
    #[ORM\ManyToOne(targetEntity: Organization::class)]
    #[ORM\JoinColumn(nullable: false)]
    #[Groups(['read'])]
    protected Organization $organization;

    public function getOrganization(): Organization
    {
        return $this->organization;
    }

    public function setOrganization(Organization $organization): self
    {
        $this->organization = $organization;
        return $this;
    }
}
```

**Tests:** `tests/Service/Generator/Entity/OrganizationTraitGeneratorTest.php`

```php
<?php

namespace App\Tests\Service\Generator\Entity;

use App\Service\Generator\Entity\OrganizationTraitGenerator;
use PHPUnit\Framework\TestCase;
use Symfony\Component\Filesystem\Filesystem;
use Twig\Environment;

class OrganizationTraitGeneratorTest extends TestCase
{
    private string $testDir;
    private OrganizationTraitGenerator $generator;

    protected function setUp(): void
    {
        $this->testDir = sys_get_temp_dir() . '/generator_test_' . uniqid();
        mkdir($this->testDir, 0755, true);

        $twig = $this->createMock(Environment::class);
        $twig->method('render')->willReturn('<?php trait OrganizationTrait {}');

        $this->generator = new OrganizationTraitGenerator(
            $this->testDir,
            $twig,
            new Filesystem()
        );
    }

    protected function tearDown(): void
    {
        (new Filesystem())->remove($this->testDir);
    }

    public function testGenerateCreatesTraitFile(): void
    {
        $result = $this->generator->generate();

        $this->assertTrue($result);
        $this->assertTrue($this->generator->exists());
    }

    public function testGenerateSkipsIfFileExists(): void
    {
        $this->generator->generate();
        $result = $this->generator->generate();

        $this->assertFalse($result); // Should skip
    }
}
```

---

## Day 3-4: Entity Generator

### Files:
- `src/Service/Generator/Entity/EntityGenerator.php`
- `templates/generator/php/entity_generated.php.twig`
- `templates/generator/php/entity_extension.php.twig`

**Purpose:** Generate entity classes with proper Doctrine configuration.

**Key Features:**
- Generates `Entity/Generated/{Entity}Generated.php` (always regenerated)
- Generates `Entity/{Entity}.php` (once, safe to edit)
- Imports OrganizationTrait when `hasOrganization=true`
- Handles all property types and relationships
- Proper UUID configuration
- Lifecycle callbacks

**Implementation:**

```php
<?php

declare(strict_types=1);

namespace App\Service\Generator\Entity;

use App\Service\Generator\Csv\EntityDefinitionDto;
use Symfony\Component\Filesystem\Filesystem;
use Twig\Environment;

class EntityGenerator
{
    public function __construct(
        private readonly string $projectDir,
        private readonly Environment $twig,
        private readonly Filesystem $filesystem
    ) {}

    /**
     * Generate entity files (Generated base + Extension)
     */
    public function generate(EntityDefinitionDto $entity): array
    {
        $generatedFiles = [];

        // Generate base class (ALWAYS regenerated)
        $generatedFiles[] = $this->generateBaseClass($entity);

        // Generate extension class (ONCE only)
        $extensionFile = $this->generateExtensionClass($entity);
        if ($extensionFile) {
            $generatedFiles[] = $extensionFile;
        }

        return $generatedFiles;
    }

    /**
     * Generate Entity/Generated/{Entity}Generated.php
     */
    private function generateBaseClass(EntityDefinitionDto $entity): string
    {
        $filePath = sprintf(
            '%s/src/Entity/Generated/%sGenerated.php',
            $this->projectDir,
            $entity->entityName
        );

        // Create directory
        $dir = dirname($filePath);
        if (!is_dir($dir)) {
            $this->filesystem->mkdir($dir, 0755);
        }

        // Render from template
        $content = $this->twig->render('generator/php/entity_generated.php.twig', [
            'entity' => $entity,
            'namespace' => 'App\\Entity\\Generated',
            'className' => $entity->entityName . 'Generated',
            'extendsClass' => 'EntityBase',
            'usesOrganizationTrait' => $entity->hasOrganization,
        ]);

        file_put_contents($filePath, $content);

        return $filePath;
    }

    /**
     * Generate Entity/{Entity}.php (ONCE only)
     */
    private function generateExtensionClass(EntityDefinitionDto $entity): ?string
    {
        $filePath = sprintf(
            '%s/src/Entity/%s.php',
            $this->projectDir,
            $entity->entityName
        );

        // Skip if exists (user may have customized)
        if (file_exists($filePath)) {
            return null;
        }

        // Render from template
        $content = $this->twig->render('generator/php/entity_extension.php.twig', [
            'entity' => $entity,
            'namespace' => 'App\\Entity',
            'className' => $entity->entityName,
            'extendsClass' => $entity->entityName . 'Generated',
        ]);

        file_put_contents($filePath, $content);

        return $filePath;
    }
}
```

**Twig Template:** `templates/generator/php/entity_generated.php.twig`

```php
<?php

declare(strict_types=1);

namespace {{ namespace }};

use App\Entity\EntityBase;
{% if usesOrganizationTrait %}
use App\Entity\Trait\OrganizationTrait;
{% endif %}
use Doctrine\ORM\Mapping as ORM;
use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\Common\Collections\Collection;
use Symfony\Component\Validator\Constraints as Assert;
use Symfony\Component\Serializer\Annotation\Groups;

/**
 * {{ entity.entityLabel }} Entity (Generated Base Class)
 *
 * This class is ALWAYS regenerated from CSV. DO NOT edit this file.
 * Add custom logic to {{ entity.entityName }}.php instead.
 *
 * @generated by Luminai Code Generator
 * @see /config/Entity.csv and /config/Property.csv
 */
#[ORM\MappedSuperclass]
#[ORM\HasLifecycleCallbacks]
abstract class {{ className }} extends {{ extendsClass }}
{
{% if usesOrganizationTrait %}
    use OrganizationTrait;

{% endif %}
{% for property in entity.properties %}
{% if not property.isRelationship %}
    #[ORM\Column(
        type: '{{ property.propertyType }}'
{%- if property.length %}, length: {{ property.length }}{% endif %}
{%- if property.precision %}, precision: {{ property.precision }}{% endif %}
{%- if property.scale %}, scale: {{ property.scale }}{% endif %}
{%- if property.nullable %}, nullable: true{% endif %}
{%- if property.unique %}, unique: true{% endif %}
    )]
{% for rule in property.validationRules %}
    #[Assert\{{ rule }}]
{% endfor %}
{% for group in property.apiGroups %}
    #[Groups(['{{ group }}'])]
{% endfor %}
    protected {{ property.getPhpType() }}{% if property.nullable %}?{% endif %} ${{ property.propertyName }}{% if property.defaultValue is not null %} = {{ property.defaultValue }}{% endif %};

{% else %}
{% if property.isCollection %}
    #[ORM\{{ property.relationshipType }}(
        targetEntity: {{ property.targetEntity }}::class
{%- if property.mappedBy %}, mappedBy: '{{ property.mappedBy }}'{% endif %}
{%- if property.inversedBy %}, inversedBy: '{{ property.inversedBy }}'{% endif %}
{%- if property.cascade %}, cascade: [{% for op in property.cascade %}'{{ op }}'{% if not loop.last %}, {% endif %}{% endfor %}]{% endif %}
{%- if property.orphanRemoval %}, orphanRemoval: true{% endif %}
{%- if property.fetch %}, fetch: '{{ property.fetch }}'{% endif %}
    )]
{% if property.orderBy %}
    #[ORM\OrderBy(['{{ property.orderBy }}' => 'ASC'])]
{% endif %}
{% for group in property.apiGroups %}
    #[Groups(['{{ group }}'])]
{% endfor %}
    protected Collection ${{ property.propertyName }};

{% else %}
    #[ORM\{{ property.relationshipType }}(targetEntity: {{ property.targetEntity }}::class{% if property.inversedBy %}, inversedBy: '{{ property.inversedBy }}'{% endif %})]
{% if not property.nullable %}
    #[ORM\JoinColumn(nullable: false)]
{% endif %}
{% for group in property.apiGroups %}
    #[Groups(['{{ group }}'])]
{% endfor %}
    protected {% if property.nullable %}?{% endif %}{{ property.targetEntity }} ${{ property.propertyName }}{% if property.nullable %} = null{% endif %};

{% endif %}
{% endif %}
{% endfor %}

    public function __construct()
    {
        parent::__construct();
{% for property in entity.properties %}
{% if property.isCollection %}
        $this->{{ property.propertyName }} = new ArrayCollection();
{% endif %}
{% endfor %}
    }

{% for property in entity.properties %}
{% if not property.isRelationship %}
    public function get{{ property.propertyName|capitalize }}(): {% if property.nullable %}?{% endif %}{{ property.getPhpType() }}
    {
        return $this->{{ property.propertyName }};
    }

    public function set{{ property.propertyName|capitalize }}({% if property.nullable %}?{% endif %}{{ property.getPhpType() }} ${{ property.propertyName }}): self
    {
        $this->{{ property.propertyName }} = ${{ property.propertyName }};
        return $this;
    }

{% else %}
{% if property.isCollection %}
    /**
     * @return Collection<int, {{ property.targetEntity }}>
     */
    public function get{{ property.propertyName|capitalize }}(): Collection
    {
        return $this->{{ property.propertyName }};
    }

    public function add{{ property.propertyName|capitalize|slice(0, -1) }}({{ property.targetEntity }} ${{ property.propertyName|slice(0, -1) }}): self
    {
        if (!$this->{{ property.propertyName }}->contains(${{ property.propertyName|slice(0, -1) }})) {
            $this->{{ property.propertyName }}->add(${{ property.propertyName|slice(0, -1) }});
{% if property.inversedBy %}
            ${{ property.propertyName|slice(0, -1) }}->set{{ property.inversedBy|capitalize }}($this);
{% endif %}
        }
        return $this;
    }

    public function remove{{ property.propertyName|capitalize|slice(0, -1) }}({{ property.targetEntity }} ${{ property.propertyName|slice(0, -1) }}): self
    {
        if ($this->{{ property.propertyName }}->removeElement(${{ property.propertyName|slice(0, -1) }})) {
{% if property.inversedBy %}
            if (${{ property.propertyName|slice(0, -1) }}->get{{ property.inversedBy|capitalize }}() === $this) {
                ${{ property.propertyName|slice(0, -1) }}->set{{ property.inversedBy|capitalize }}(null);
            }
{% endif %}
        }
        return $this;
    }

{% else %}
    public function get{{ property.propertyName|capitalize }}(): {% if property.nullable %}?{% endif %}{{ property.targetEntity }}
    {
        return $this->{{ property.propertyName }};
    }

    public function set{{ property.propertyName|capitalize }}({% if property.nullable %}?{% endif %}{{ property.targetEntity }} ${{ property.propertyName }}): self
    {
        $this->{{ property.propertyName }} = ${{ property.propertyName }};
        return $this;
    }

{% endif %}
{% endif %}
{% endfor %}

    public function __toString(): string
    {
{% if entity.properties|filter(p => p.propertyName == 'name')|length > 0 %}
        return $this->name ?? '';
{% else %}
        return (string) $this->getId();
{% endif %}
    }
}
```

**Twig Template:** `templates/generator/php/entity_extension.php.twig`

```php
<?php

declare(strict_types=1);

namespace {{ namespace }};

use App\Entity\Generated\{{ entity.entityName }}Generated;
use App\Repository\{{ entity.entityName }}Repository;
use Doctrine\ORM\Mapping as ORM;

/**
 * {{ entity.entityLabel }} Entity
 *
 * This class extends the generated base and is SAFE TO EDIT.
 * Add custom business logic, methods, and overrides here.
 *
 * @generated once by Luminai Code Generator
 */
#[ORM\Entity(repositoryClass: {{ entity.entityName }}Repository::class)]
#[ORM\Table(name: '{{ entity.getSnakeCaseName() }}')]
class {{ className }} extends {{ extendsClass }}
{
    // Add custom properties here

    // Add custom methods here
}
```

---

## Day 5: API Platform YAML Generator

### File: `src/Service/Generator/ApiPlatform/ApiPlatformGenerator.php`

**Purpose:** Generate YAML configuration for API Platform.

**Why YAML:** Separates API configuration from entity code, allowing full regeneration without parsing PHP.

**Implementation:**

```php
<?php

declare(strict_types=1);

namespace App\Service\Generator\ApiPlatform;

use App\Service/Generator\Csv\EntityDefinitionDto;
use Symfony\Component\Filesystem\Filesystem;
use Twig\Environment;

class ApiPlatformGenerator
{
    public function __construct(
        private readonly string $projectDir,
        private readonly Environment $twig,
        private readonly Filesystem $filesystem
    ) {}

    /**
     * Generate API Platform YAML configuration
     */
    public function generate(EntityDefinitionDto $entity): string
    {
        if (!$entity->apiEnabled) {
            return ''; // Skip if API not enabled
        }

        $filePath = sprintf(
            '%s/config/api_platform/%s.yaml',
            $this->projectDir,
            $entity->entityName
        );

        // Create directory
        $dir = dirname($filePath);
        if (!is_dir($dir)) {
            $this->filesystem->mkdir($dir, 0755);
        }

        // Render from template
        $content = $this->twig->render('generator/yaml/api_platform_resource.yaml.twig', [
            'entity' => $entity,
        ]);

        file_put_contents($filePath, $content);

        return $filePath;
    }
}
```

**Twig Template:** `templates/generator/yaml/api_platform_resource.yaml.twig`

```yaml
# API Platform Configuration for {{ entity.entityName }}
# This file is ALWAYS regenerated from CSV. DO NOT edit manually.
# @see /config/Entity.csv for configuration

resources:
  App\Entity\{{ entity.entityName }}:
    shortName: {{ entity.apiShortName|default(entity.entityName) }}
    description: {{ entity.apiDescription|default(entity.description) }}

    normalizationContext:
      groups: [{{ entity.normalizationContext|split(',')|join(', ') }}]

    denormalizationContext:
      groups: [{{ entity.denormalizationContext|split(',')|join(', ') }}]

{% if entity.paginationEnabled %}
    paginationEnabled: true
    paginationItemsPerPage: {{ entity.itemsPerPage }}
{% endif %}

{% if entity.order %}
    order:
{% for field, direction in entity.order %}
      {{ field }}: {{ direction|upper }}
{% endfor %}
{% endif %}

    operations:
{% for operation in entity.operations %}
{% set index = loop.index0 %}
{% set operationSecurity = entity.apiSecurity[index]|default("is_granted('ROLE_USER')") %}
      {{ operation }}:
        security: "{{ operationSecurity }}"
{% if operation == 'GetCollection' %}
        filters: [{{ entity.filterableFields|join(', ') }}]
{% endif %}
{% endfor %}
```

---

## Day 6-7: Repository Generator (NEW: Abstract Layer)

### Files:
- `src/Service/Generator/Repository/RepositoryGenerator.php`
- `templates/generator/php/repository_generated.php.twig`
- `templates/generator/php/repository_extension.php.twig`

**Purpose:** Generate repository classes with search/filter capabilities.

**NEW in V4:** Repositories now follow the Generated + Extension pattern like other components.

**Implementation:**

```php
<?php

declare(strict_types=1);

namespace App\Service\Generator\Repository;

use App\Service\Generator\Csv\EntityDefinitionDto;
use Symfony\Component\Filesystem\Filesystem;
use Twig\Environment;

class RepositoryGenerator
{
    public function __construct(
        private readonly string $projectDir,
        private readonly Environment $twig,
        private readonly Filesystem $filesystem
    ) {}

    /**
     * Generate repository files (Generated base + Extension)
     */
    public function generate(EntityDefinitionDto $entity): array
    {
        $generatedFiles = [];

        // Generate base class (ALWAYS regenerated)
        $generatedFiles[] = $this->generateBaseClass($entity);

        // Generate extension class (ONCE only)
        $extensionFile = $this->generateExtensionClass($entity);
        if ($extensionFile) {
            $generatedFiles[] = $extensionFile;
        }

        return $generatedFiles;
    }

    /**
     * Generate Repository/Generated/{Entity}RepositoryGenerated.php
     */
    private function generateBaseClass(EntityDefinitionDto $entity): string
    {
        $filePath = sprintf(
            '%s/src/Repository/Generated/%sRepositoryGenerated.php',
            $this->projectDir,
            $entity->entityName
        );

        // Create directory
        $dir = dirname($filePath);
        if (!is_dir($dir)) {
            $this->filesystem->mkdir($dir, 0755);
        }

        // Render from template
        $content = $this->twig->render('generator/php/repository_generated.php.twig', [
            'entity' => $entity,
            'namespace' => 'App\\Repository\\Generated',
            'className' => $entity->entityName . 'RepositoryGenerated',
        ]);

        file_put_contents($filePath, $content);

        return $filePath;
    }

    /**
     * Generate Repository/{Entity}Repository.php (ONCE only)
     */
    private function generateExtensionClass(EntityDefinitionDto $entity): ?string
    {
        $filePath = sprintf(
            '%s/src/Repository/%sRepository.php',
            $this->projectDir,
            $entity->entityName
        );

        // Skip if exists (user may have added custom queries)
        if (file_exists($filePath)) {
            return null;
        }

        // Render from template
        $content = $this->twig->render('generator/php/repository_extension.php.twig', [
            'entity' => $entity,
            'namespace' => 'App\\Repository',
            'className' => $entity->entityName . 'Repository',
            'extendsClass' => $entity->entityName . 'RepositoryGenerated',
        ]);

        file_put_contents($filePath, $content);

        return $filePath;
    }
}
```

**Twig Template:** `templates/generator/php/repository_generated.php.twig`

```php
<?php

declare(strict_types=1);

namespace {{ namespace }};

use App\Entity\{{ entity.entityName }};
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;
use Doctrine\ORM\QueryBuilder;

/**
 * {{ entity.entityName }} Repository (Generated Base Class)
 *
 * This class is ALWAYS regenerated from CSV. DO NOT edit this file.
 * Add custom queries to {{ entity.entityName }}Repository.php instead.
 *
 * @generated by Luminai Code Generator
 * @method {{ entity.entityName }}|null find($id, $lockMode = null, $lockVersion = null)
 * @method {{ entity.entityName }}|null findOneBy(array $criteria, array $orderBy = null)
 * @method {{ entity.entityName }}[]    findAll()
 * @method {{ entity.entityName }}[]    findBy(array $criteria, array $orderBy = null, $limit = null, $offset = null)
 */
abstract class {{ className }} extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, {{ entity.entityName }}::class);
    }

    /**
     * Get searchable fields for full-text search
     */
    protected function getSearchableFields(): array
    {
        return [
{% for field in entity.searchableFields %}
            '{{ field }}',
{% endfor %}
        ];
    }

    /**
     * Search {{ entity.pluralLabel }} by term
     *
     * @return {{ entity.entityName }}[]
     */
    public function search(string $term, int $limit = 20): array
    {
        $qb = $this->createQueryBuilder('e');

        if (!empty($term)) {
            $orX = $qb->expr()->orX();
            foreach ($this->getSearchableFields() as $field) {
                $orX->add($qb->expr()->like("e.{$field}", ':term'));
            }
            $qb->andWhere($orX)
               ->setParameter('term', '%' . $term . '%');
        }

        return $qb->setMaxResults($limit)
                  ->getQuery()
                  ->getResult();
    }

    /**
     * Create filtered query builder
     */
    public function createFilteredQueryBuilder(array $filters = []): QueryBuilder
    {
        $qb = $this->createQueryBuilder('e');

{% for field in entity.filterableFields %}
        if (isset($filters['{{ field }}'])) {
            $qb->andWhere('e.{{ field }} = :{{ field }}')
               ->setParameter('{{ field }}', $filters['{{ field }}']);
        }
{% endfor %}

        return $qb;
    }

    /**
     * Count all {{ entity.pluralLabel }}
     */
    public function count(array $criteria = []): int
    {
        return (int) $this->createQueryBuilder('e')
            ->select('COUNT(e.id)')
            ->getQuery()
            ->getSingleScalarResult();
    }
}
```

**Twig Template:** `templates/generator/php/repository_extension.php.twig`

```php
<?php

declare(strict_types=1);

namespace {{ namespace }};

use App\Repository\Generated\{{ entity.entityName }}RepositoryGenerated;

/**
 * {{ entity.entityName }} Repository
 *
 * This class extends the generated base and is SAFE TO EDIT.
 * Add custom query methods and complex logic here.
 *
 * @generated once by Luminai Code Generator
 */
class {{ className }} extends {{ extendsClass }}
{
    // Add custom query methods here

    // Example:
    // public function findByCustomCriteria($criteria): array
    // {
    //     return $this->createQueryBuilder('e')
    //         ->andWhere('e.field = :value')
    //         ->setParameter('value', $criteria)
    //         ->orderBy('e.createdAt', 'DESC')
    //         ->getQuery()
    //         ->getResult();
    // }
}
```

---

## Day 8: Controller Generator

### File: `src/Service/Generator/Controller/ControllerGenerator.php`

**Purpose:** Generate controller classes with CRUD actions.

**Key Features:**
- Turbo Drive compatible
- Organization context integration
- Flash messages
- Security via voters

**Implementation:**

```php
<?php

declare(strict_types=1);

namespace App\Service\Generator\Controller;

use App\Service\Generator\Csv\EntityDefinitionDto;
use Symfony\Component\Filesystem\Filesystem;
use Twig\Environment;

class ControllerGenerator
{
    public function __construct(
        private readonly string $projectDir,
        private readonly Environment $twig,
        private readonly Filesystem $filesystem
    ) {}

    /**
     * Generate controller files (Generated base + Extension)
     */
    public function generate(EntityDefinitionDto $entity): array
    {
        $generatedFiles = [];

        // Generate base class (ALWAYS regenerated)
        $generatedFiles[] = $this->generateBaseClass($entity);

        // Generate extension class (ONCE only)
        $extensionFile = $this->generateExtensionClass($entity);
        if ($extensionFile) {
            $generatedFiles[] = $extensionFile;
        }

        return $generatedFiles;
    }

    private function generateBaseClass(EntityDefinitionDto $entity): string
    {
        $filePath = sprintf(
            '%s/src/Controller/Generated/%sControllerGenerated.php',
            $this->projectDir,
            $entity->entityName
        );

        $dir = dirname($filePath);
        if (!is_dir($dir)) {
            $this->filesystem->mkdir($dir, 0755);
        }

        $content = $this->twig->render('generator/php/controller_generated.php.twig', [
            'entity' => $entity,
            'namespace' => 'App\\Controller\\Generated',
            'className' => $entity->entityName . 'ControllerGenerated',
        ]);

        file_put_contents($filePath, $content);

        return $filePath;
    }

    private function generateExtensionClass(EntityDefinitionDto $entity): ?string
    {
        $filePath = sprintf(
            '%s/src/Controller/%sController.php',
            $this->projectDir,
            $entity->entityName
        );

        if (file_exists($filePath)) {
            return null;
        }

        $content = $this->twig->render('generator/php/controller_extension.php.twig', [
            'entity' => $entity,
            'namespace' => 'App\\Controller',
            'className' => $entity->entityName . 'Controller',
            'extendsClass' => $entity->entityName . 'ControllerGenerated',
        ]);

        file_put_contents($filePath, $content);

        return $filePath;
    }
}
```

*(Controller templates are complex and will be detailed in the full implementation)*

---

## Day 9: Voter Generator

### File: `src/Service/Generator/Voter/VoterGenerator.php`

**Purpose:** Generate security voters for entity access control.

**Implementation:** Similar pattern to Controller - Generated base + Extension.

---

## Day 10: Form Generator

### File: `src/Service/Generator/Form/FormGenerator.php`

**Purpose:** Generate Symfony form types for entity CRUD.

**Key Features:**
- Maps Doctrine types to form types
- Handles relationships with EntityType
- Proper form options and constraints
- Organization field excluded (hidden)

**Implementation:** Similar pattern - Generated base + Extension.

---

## Phase 2 Deliverables Checklist

- [ ] OrganizationTrait Generator implemented and tested
- [ ] Entity Generator implemented and tested
- [ ] API Platform YAML Generator implemented and tested
- [ ] Repository Generator (abstract layer) implemented and tested
- [ ] Controller Generator implemented and tested
- [ ] Voter Generator implemented and tested
- [ ] Form Generator implemented and tested
- [ ] All unit tests pass (80%+ coverage)
- [ ] Code passes PHPStan level 8
- [ ] Templates validated

---

## Next Phase

**Phase 3: UI Generators** (Week 4)
- Template Generator (index, form, show views)
- Navigation Generator
- Translation Generator
