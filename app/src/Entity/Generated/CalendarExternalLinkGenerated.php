<?php

declare(strict_types=1);

namespace App\Entity\Generated;

use App\Entity\EntityBase;
use Doctrine\ORM\Mapping as ORM;
use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\Common\Collections\Collection;
use Symfony\Component\Validator\Constraints as Assert;
use Symfony\Component\Serializer\Annotation\Groups;
use App\Entity\Calendar;
use App\Entity\User;

/**
 * Calendar External Link Entity (Generated Base Class)
 *
 * Manages OAuth-based external calendar integrations (Google Calendar, Microsoft Outlook, Apple Calendar) with bi-directional sync, webhook support, and token refresh management *
 * This class is ALWAYS regenerated. DO NOT edit this file.
 * Add custom logic to CalendarExternalLink.php instead.
 *
 * @generated by Genmax Code Generator
 */
#[ORM\MappedSuperclass]
#[ORM\HasLifecycleCallbacks]
abstract class CalendarExternalLinkGenerated extends EntityBase
{
    #[Groups(['calendarexternallink:read', 'calendarexternallink:write'])]
    #[ORM\Column(type: 'string', length: 255)]
    #[Assert\Length(max: 100)]
    protected string $name;

    #[Groups(['calendarexternallink:read', 'calendarexternallink:write'])]
    #[ORM\OneToMany(targetEntity: Calendar::class, mappedBy: 'externalLink', cascade: ['persist', 'remove'], orphanRemoval: true, fetch: 'LAZY')]
    protected Collection $calendars;

    #[Groups(['calendarexternallink:read', 'calendarexternallink:write'])]
    #[ORM\Column(type: 'string', length: 50)]
    #[Assert\Length(max: 50)]
    protected string $externalProvider;

    #[Groups(['calendarexternallink:read', 'calendarexternallink:write'])]
    #[ORM\Column(type: 'boolean')]
    protected bool $active = true;

    #[Groups(['calendarexternallink:read', 'calendarexternallink:write'])]
    #[ORM\Column(type: 'string', length: 255, nullable: true)]
    protected ?string $externalId = null;

    #[Groups(['calendarexternallink:read', 'calendarexternallink:write'])]
    #[ORM\Column(type: 'string', length: 500, nullable: true)]
    #[Assert\Length(max: 500)]
    protected ?string $url = null;

    #[Groups(['calendarexternallink:read', 'calendarexternallink:write'])]
    #[ORM\Column(type: 'text', nullable: true)]
    protected ?string $accessToken = null;

    #[Groups(['calendarexternallink:read', 'calendarexternallink:write'])]
    #[ORM\Column(type: 'text', nullable: true)]
    protected ?string $refreshToken = null;

    #[Groups(['calendarexternallink:read', 'calendarexternallink:write'])]
    #[ORM\Column(type: 'datetime', nullable: true)]
    protected ?\DateTimeImmutable $tokenExpiresAt = null;

    #[Groups(['calendarexternallink:read', 'calendarexternallink:write'])]
    #[ORM\Column(type: 'string', length: 500, nullable: true)]
    #[Assert\Length(max: 500)]
    protected ?string $syncToken = null;

    #[Groups(['calendarexternallink:read', 'calendarexternallink:write'])]
    #[ORM\Column(type: 'datetime', nullable: true)]
    protected ?\DateTimeImmutable $lastSyncedAt = null;

    #[Groups(['calendarexternallink:read', 'calendarexternallink:write'])]
    #[ORM\Column(type: 'string', length: 500, nullable: true)]
    #[Assert\Length(max: 500)]
    protected ?string $webhookUrl = null;

    #[Groups(['calendarexternallink:read', 'calendarexternallink:write'])]
    #[ORM\Column(type: 'string', length: 255, nullable: true)]
    #[Assert\Length(max: 255)]
    protected ?string $webhookChannelId = null;

    #[Groups(['calendarexternallink:read', 'calendarexternallink:write'])]
    #[ORM\Column(type: 'datetime', nullable: true)]
    protected ?\DateTimeImmutable $webhookExpiresAt = null;

    #[Groups(['calendarexternallink:read', 'calendarexternallink:write'])]
    #[ORM\Column(type: 'string', length: 255)]
    protected string $syncDirection = 'bidirectional';

    #[Groups(['calendarexternallink:read', 'calendarexternallink:write'])]
    #[ORM\Column(type: 'text', nullable: true)]
    protected ?string $lastErrorMessage = null;

    #[Groups(['calendarexternallink:read', 'calendarexternallink:write'])]
    #[ORM\Column(type: 'datetime', nullable: true)]
    protected ?\DateTimeImmutable $lastErrorAt = null;

    #[Groups(['calendarexternallink:read', 'calendarexternallink:write'])]
    #[ORM\Column(type: 'integer')]
    protected int $syncIntervalMinutes = 15;

    #[Groups(['calendarexternallink:read', 'calendarexternallink:write'])]
    #[ORM\Column(type: 'integer')]
    protected int $retryCount = 0;

    #[Groups(['calendarexternallink:read', 'calendarexternallink:write'])]
    #[ORM\Column(type: 'json', nullable: true)]
    protected ?array $scopes = null;

    #[Groups(['calendarexternallink:read', 'calendarexternallink:write'])]
    #[ORM\Column(type: 'json', nullable: true)]
    protected ?array $metadata = null;

    #[Groups(['calendarexternallink:read', 'calendarexternallink:write'])]
    #[ORM\ManyToOne(targetEntity: User::class, inversedBy: 'calendarExternalLinks')]
    #[ORM\JoinColumn(nullable: false)]
    protected User $user;


    public function __construct()
    {
        parent::__construct();
        $this->calendars = new ArrayCollection();
    }

    public function getName(): string    {
        return $this->name;
    }

    public function setName(string $name): self
    {
        $this->name = $name;
        return $this;
    }

    /**
     * @return Collection<int, Calendar>
     */
    public function getCalendars(): Collection
    {
        return $this->calendars;
    }

    public function addCalendar(Calendar $calendar): self
    {
        if (!$this->calendars->contains($calendar)) {
            $this->calendars->add($calendar);
            $calendar->setExternalLink($this);
        }
        return $this;
    }

    public function removeCalendar(Calendar $calendar): self
    {
        if ($this->calendars->removeElement($calendar)) {
            if ($calendar->getExternalLink() === $this) {
                $calendar->setExternalLink(null);
            }
        }
        return $this;
    }

    public function getExternalProvider(): string    {
        return $this->externalProvider;
    }

    public function setExternalProvider(string $externalProvider): self
    {
        $this->externalProvider = $externalProvider;
        return $this;
    }

    public function getActive(): bool    {
        return $this->active;
    }

    public function setActive(bool $active): self
    {
        $this->active = $active;
        return $this;
    }

    public function isActive(): bool
    {
        return $this->active === true;
    }

    public function getExternalId(): ?string    {
        return $this->externalId;
    }

    public function setExternalId(?string $externalId): self
    {
        $this->externalId = $externalId;
        return $this;
    }

    public function getUrl(): ?string    {
        return $this->url;
    }

    public function setUrl(?string $url): self
    {
        $this->url = $url;
        return $this;
    }

    public function getAccessToken(): ?string    {
        return $this->accessToken;
    }

    public function setAccessToken(?string $accessToken): self
    {
        $this->accessToken = $accessToken;
        return $this;
    }

    public function getRefreshToken(): ?string    {
        return $this->refreshToken;
    }

    public function setRefreshToken(?string $refreshToken): self
    {
        $this->refreshToken = $refreshToken;
        return $this;
    }

    public function getTokenExpiresAt(): ?\DateTimeImmutable    {
        return $this->tokenExpiresAt;
    }

    public function setTokenExpiresAt(?\DateTimeImmutable $tokenExpiresAt): self
    {
        $this->tokenExpiresAt = $tokenExpiresAt;
        return $this;
    }

    public function getSyncToken(): ?string    {
        return $this->syncToken;
    }

    public function setSyncToken(?string $syncToken): self
    {
        $this->syncToken = $syncToken;
        return $this;
    }

    public function getLastSyncedAt(): ?\DateTimeImmutable    {
        return $this->lastSyncedAt;
    }

    public function setLastSyncedAt(?\DateTimeImmutable $lastSyncedAt): self
    {
        $this->lastSyncedAt = $lastSyncedAt;
        return $this;
    }

    public function getWebhookUrl(): ?string    {
        return $this->webhookUrl;
    }

    public function setWebhookUrl(?string $webhookUrl): self
    {
        $this->webhookUrl = $webhookUrl;
        return $this;
    }

    public function getWebhookChannelId(): ?string    {
        return $this->webhookChannelId;
    }

    public function setWebhookChannelId(?string $webhookChannelId): self
    {
        $this->webhookChannelId = $webhookChannelId;
        return $this;
    }

    public function getWebhookExpiresAt(): ?\DateTimeImmutable    {
        return $this->webhookExpiresAt;
    }

    public function setWebhookExpiresAt(?\DateTimeImmutable $webhookExpiresAt): self
    {
        $this->webhookExpiresAt = $webhookExpiresAt;
        return $this;
    }

    public function getSyncDirection(): string    {
        return $this->syncDirection;
    }

    public function setSyncDirection(string $syncDirection): self
    {
        $this->syncDirection = $syncDirection;
        return $this;
    }

    public function getLastErrorMessage(): ?string    {
        return $this->lastErrorMessage;
    }

    public function setLastErrorMessage(?string $lastErrorMessage): self
    {
        $this->lastErrorMessage = $lastErrorMessage;
        return $this;
    }

    public function getLastErrorAt(): ?\DateTimeImmutable    {
        return $this->lastErrorAt;
    }

    public function setLastErrorAt(?\DateTimeImmutable $lastErrorAt): self
    {
        $this->lastErrorAt = $lastErrorAt;
        return $this;
    }

    public function getSyncIntervalMinutes(): int    {
        return $this->syncIntervalMinutes;
    }

    public function setSyncIntervalMinutes(int $syncIntervalMinutes): self
    {
        $this->syncIntervalMinutes = $syncIntervalMinutes;
        return $this;
    }

    public function getRetryCount(): int    {
        return $this->retryCount;
    }

    public function setRetryCount(int $retryCount): self
    {
        $this->retryCount = $retryCount;
        return $this;
    }

    public function getScopes(): ?array    {
        return $this->scopes;
    }

    public function setScopes(?array $scopes): self
    {
        $this->scopes = $scopes;
        return $this;
    }

    public function getMetadata(): ?array    {
        return $this->metadata;
    }

    public function setMetadata(?array $metadata): self
    {
        $this->metadata = $metadata;
        return $this;
    }

    public function getUser(): User
    {
        return $this->user;
    }

    public function setUser(User $user): self
    {
        $this->user = $user;
        return $this;
    }


    public function __toString(): string
    {
        return $this->name ?? ($this->getId()?->toRfc4122() ?? '');
    }
}
