<?php

declare(strict_types=1);

namespace App\Dto\Generated;

use Symfony\Component\Validator\Constraints as Assert;
use Symfony\Component\Validator\Context\ExecutionContextInterface;
use Symfony\Component\Serializer\Annotation\Groups;
use App\Dto\UserInputDto;

/**
 * Calendar External Link Input DTO (Generated Base Class)
 *
 * Manages OAuth-based external calendar integrations (Google Calendar, Microsoft Outlook, Apple Calendar) with bi-directional sync, webhook support, and token refresh management *
 * This class is ALWAYS regenerated. DO NOT edit this file.
 * Add custom validation logic to CalendarExternalLinkInputDto.php instead.
 *
 * @generated by Genmax Code Generator
 */
abstract class CalendarExternalLinkInputDtoGenerated
{
    #[Assert\Length(max: 100)]
    #[Groups(['calendarexternallink:write'])]
    public string $name;

    #[Assert\Length(max: 50)]
    #[Groups(['calendarexternallink:write'])]
    public string $externalProvider;

    #[Groups(['calendarexternallink:write'])]
    public bool $active = true;

    #[Groups(['calendarexternallink:write'])]
    public ?string $externalId = null;

    #[Assert\Length(max: 500)]
    #[Groups(['calendarexternallink:write'])]
    public ?string $url = null;

    #[Groups(['calendarexternallink:write'])]
    public ?string $accessToken = null;

    #[Groups(['calendarexternallink:write'])]
    public ?string $refreshToken = null;

    #[Groups(['calendarexternallink:write'])]
    public ?\DateTimeImmutable $tokenExpiresAt = null;

    #[Assert\Length(max: 500)]
    #[Groups(['calendarexternallink:write'])]
    public ?string $syncToken = null;

    #[Groups(['calendarexternallink:write'])]
    public ?\DateTimeImmutable $lastSyncedAt = null;

    #[Assert\Length(max: 500)]
    #[Groups(['calendarexternallink:write'])]
    public ?string $webhookUrl = null;

    #[Assert\Length(max: 255)]
    #[Groups(['calendarexternallink:write'])]
    public ?string $webhookChannelId = null;

    #[Groups(['calendarexternallink:write'])]
    public ?\DateTimeImmutable $webhookExpiresAt = null;

    #[Groups(['calendarexternallink:write'])]
    public string $syncDirection = 'bidirectional';

    #[Groups(['calendarexternallink:write'])]
    public ?string $lastErrorMessage = null;

    #[Groups(['calendarexternallink:write'])]
    public ?\DateTimeImmutable $lastErrorAt = null;

    #[Groups(['calendarexternallink:write'])]
    public int $syncIntervalMinutes = 15;

    #[Groups(['calendarexternallink:write'])]
    public int $retryCount = 0;

    #[Groups(['calendarexternallink:write'])]
    public ?array $scopes = null;

    #[Groups(['calendarexternallink:write'])]
    public ?array $metadata = null;

    /**
     * user reference
     * Must be: IRI string (e.g., "/api/users/uuid")
     */
    #[Assert\NotNull]
    #[Groups(['calendarexternallink:write'])]
    public ?string $user = null;


    // Getters and Setters

    public function getName(): string    {
        return $this->name;
    }

    public function setName(string $name): self
    {
        $this->name = $name;
        return $this;
    }

    public function getCalendars(): ?string    {
        return $this->calendars;
    }

    public function setCalendars(?string $calendars): self
    {
        $this->calendars = $calendars;
        return $this;
    }

    public function getExternalProvider(): string    {
        return $this->externalProvider;
    }

    public function setExternalProvider(string $externalProvider): self
    {
        $this->externalProvider = $externalProvider;
        return $this;
    }

    public function getActive(): bool    {
        return $this->active;
    }

    public function setActive(bool $active): self
    {
        $this->active = $active;
        return $this;
    }

    public function getExternalId(): ?string    {
        return $this->externalId;
    }

    public function setExternalId(?string $externalId): self
    {
        $this->externalId = $externalId;
        return $this;
    }

    public function getUrl(): ?string    {
        return $this->url;
    }

    public function setUrl(?string $url): self
    {
        $this->url = $url;
        return $this;
    }

    public function getAccessToken(): ?string    {
        return $this->accessToken;
    }

    public function setAccessToken(?string $accessToken): self
    {
        $this->accessToken = $accessToken;
        return $this;
    }

    public function getRefreshToken(): ?string    {
        return $this->refreshToken;
    }

    public function setRefreshToken(?string $refreshToken): self
    {
        $this->refreshToken = $refreshToken;
        return $this;
    }

    public function getTokenExpiresAt(): ?\DateTimeImmutable    {
        return $this->tokenExpiresAt;
    }

    public function setTokenExpiresAt(?\DateTimeImmutable $tokenExpiresAt): self
    {
        $this->tokenExpiresAt = $tokenExpiresAt;
        return $this;
    }

    public function getSyncToken(): ?string    {
        return $this->syncToken;
    }

    public function setSyncToken(?string $syncToken): self
    {
        $this->syncToken = $syncToken;
        return $this;
    }

    public function getLastSyncedAt(): ?\DateTimeImmutable    {
        return $this->lastSyncedAt;
    }

    public function setLastSyncedAt(?\DateTimeImmutable $lastSyncedAt): self
    {
        $this->lastSyncedAt = $lastSyncedAt;
        return $this;
    }

    public function getWebhookUrl(): ?string    {
        return $this->webhookUrl;
    }

    public function setWebhookUrl(?string $webhookUrl): self
    {
        $this->webhookUrl = $webhookUrl;
        return $this;
    }

    public function getWebhookChannelId(): ?string    {
        return $this->webhookChannelId;
    }

    public function setWebhookChannelId(?string $webhookChannelId): self
    {
        $this->webhookChannelId = $webhookChannelId;
        return $this;
    }

    public function getWebhookExpiresAt(): ?\DateTimeImmutable    {
        return $this->webhookExpiresAt;
    }

    public function setWebhookExpiresAt(?\DateTimeImmutable $webhookExpiresAt): self
    {
        $this->webhookExpiresAt = $webhookExpiresAt;
        return $this;
    }

    public function getSyncDirection(): string    {
        return $this->syncDirection;
    }

    public function setSyncDirection(string $syncDirection): self
    {
        $this->syncDirection = $syncDirection;
        return $this;
    }

    public function getLastErrorMessage(): ?string    {
        return $this->lastErrorMessage;
    }

    public function setLastErrorMessage(?string $lastErrorMessage): self
    {
        $this->lastErrorMessage = $lastErrorMessage;
        return $this;
    }

    public function getLastErrorAt(): ?\DateTimeImmutable    {
        return $this->lastErrorAt;
    }

    public function setLastErrorAt(?\DateTimeImmutable $lastErrorAt): self
    {
        $this->lastErrorAt = $lastErrorAt;
        return $this;
    }

    public function getSyncIntervalMinutes(): int    {
        return $this->syncIntervalMinutes;
    }

    public function setSyncIntervalMinutes(int $syncIntervalMinutes): self
    {
        $this->syncIntervalMinutes = $syncIntervalMinutes;
        return $this;
    }

    public function getRetryCount(): int    {
        return $this->retryCount;
    }

    public function setRetryCount(int $retryCount): self
    {
        $this->retryCount = $retryCount;
        return $this;
    }

    public function getScopes(): ?array    {
        return $this->scopes;
    }

    public function setScopes(?array $scopes): self
    {
        $this->scopes = $scopes;
        return $this;
    }

    public function getMetadata(): ?array    {
        return $this->metadata;
    }

    public function setMetadata(?array $metadata): self
    {
        $this->metadata = $metadata;
        return $this;
    }

    public function getUser(): ?string    {
        return $this->user;
    }

    public function setUser(?string $user): self
    {
        $this->user = $user;
        return $this;
    }
}
