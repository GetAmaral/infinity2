<?php

declare(strict_types=1);

namespace {{ generated_namespace }};

use Symfony\Component\Validator\Constraints as Assert;
use Symfony\Component\Validator\Context\ExecutionContextInterface;
use Symfony\Component\Serializer\Annotation\Groups;
{% set hasCollections = false %}
{% set writeGroups = entity.getApiDenormalizationContext().groups ?? [] %}
{% for property in entity.getProperties() %}
{% if property.getRelationshipType() in ['OneToMany', 'ManyToMany'] and property.isDtoNestedEnabled() %}
{% set hasCollections = true %}
{% endif %}
{% endfor %}
{% set excludedProperties = entity.getDtoExcludedProperties() ?? [] %}
{% set targetEntities = [] %}
{% for property in entity.getProperties() %}
{% if property.getRelationshipType() and property.getTargetEntity() and property.getTargetEntity() not in targetEntities and property.getPropertyName() not in excludedProperties %}
{% if property.getRelationshipType() in ['ManyToOne', 'OneToOne'] or property.isDtoNestedEnabled() %}
{% set targetEntities = targetEntities|merge([property.getTargetEntity()]) %}
{% endif %}
{% endif %}
{% endfor %}
{% for targetEntity in targetEntities %}
use {{ dto_namespace }}\{{ targetEntity }}InputDto;
{% endfor %}

/**
 * {{ entity.getEntityLabel() }} Input DTO (Generated Base Class)
 *
 * {% if entity.getDescription() %}{{ entity.getDescription() }}{% endif %}
 *
 * This class is ALWAYS regenerated. DO NOT edit this file.
 * Add custom validation logic to {{ entity.getEntityName() }}InputDto.php instead.
 *
 * @generated by Genmax Code Generator
 */
abstract class {{ entity.getEntityName() }}InputDtoGenerated
{
{% for property in entity.getProperties() %}
{% if property.getPropertyName() not in excludedProperties %}
{% if not property.getRelationshipType() %}
{# Scalar properties #}
{% if property.getValidationRules() and property.getValidationRules() is iterable %}
{% for rule in property.getValidationRules() %}
{% if rule.constraint is defined and rule.constraint is not empty %}
{% set ruleOptions = rule.options is defined ? rule.options : (rule|filter((v, k) => k != 'constraint')) %}
    #[Assert\{{ rule.constraint }}{% if ruleOptions is not empty %}({% for paramKey, paramValue in ruleOptions %}{{ paramKey }}: {% if paramValue is iterable %}[{% for item in paramValue %}'{{ item }}'{% if not loop.last %}, {% endif %}{% endfor %}]{% elseif paramValue is same as(true) %}true{% elseif paramValue is same as(false) %}false{% elseif paramValue is null %}null{% elseif paramValue matches '/^[0-9.]+$/' %}{{ paramValue }}{% else %}'{{ paramValue }}'{% endif %}{% if not loop.last %}, {% endif %}{% endfor %}){% endif %}]
{% endif %}
{% endfor %}
{% endif %}
{% if writeGroups is not empty %}
    #[Groups([{% for group in writeGroups %}'{{ group }}'{% if not loop.last %}, {% endif %}{% endfor %}])]
{% endif %}
    public {% if property.isNullable() %}?{% endif %}{% if property.getPropertyType() == 'boolean' %}bool{% elseif property.getPropertyType() == 'integer' %}int{% elseif property.getPropertyType() == 'float' %}float{% elseif property.getPropertyType() == 'decimal' %}string{% elseif property.getPropertyType() in ['datetime', 'datetime_immutable', 'date', 'date_immutable'] %}\DateTimeImmutable{% elseif property.getPropertyType() == 'json' %}array{% else %}string{% endif %} ${{ property.getPropertyName() }}{% if property.getDefaultValue() is same as(true) %} = true{% elseif property.getDefaultValue() is same as(false) %} = false{% elseif property.getDefaultValue() is not null and property.getPropertyType() in ['string', 'text', 'decimal'] %} = '{{ property.getDefaultValue() }}'{% elseif property.getDefaultValue() is not null %} = {{ property.getDefaultValue() }}{% elseif property.isNullable() %} = null{% endif %};

{% else %}
{# Relationship properties #}
{% if property.getRelationshipType() in ['OneToMany', 'ManyToMany'] %}
{% if property.isDtoNestedEnabled() %}
    /**
     * Nested {{ property.getPropertyName() }} collection
     * Strategy: {{ property.getDtoNestedStrategy() ?? 'create_and_update' }}
     {% if property.getDtoNestedMaxItems() %}* Max items: {{ property.getDtoNestedMaxItems() }}{% endif %}
     */
    #[Assert\Valid]
{% if property.getDtoNestedMaxItems() %}
    #[Assert\Count(max: {{ property.getDtoNestedMaxItems() }}, maxMessage: 'Cannot have more than {{ property.getDtoNestedMaxItems() }} {{ property.getPropertyName() }}')]
{% endif %}
{% if writeGroups is not empty %}
    #[Groups([{% for group in writeGroups %}'{{ group }}'{% if not loop.last %}, {% endif %}{% endfor %}])]
{% endif %}
    public array ${{ property.getPropertyName() }} = [];

{% endif %}
{% else %}
{# ManyToOne or OneToOne - use IRI string only (no union type to prevent API Platform auto-deserialization) #}
    /**
     * {{ property.getPropertyName() }} reference
     * Must be: IRI string (e.g., "/api/{{ toApiResourceName(property.getTargetEntity()) }}/uuid")
{% if property.getPropertyName() == 'organization' or property.getPropertyName() == 'owner' %}
     * Auto-assigned by system if not provided
{% endif %}
     */
{% if not property.isNullable() and property.getPropertyName() != 'organization' and property.getPropertyName() != 'owner' %}
    #[Assert\NotNull]
{% endif %}
{% if writeGroups is not empty %}
    #[Groups([{% for group in writeGroups %}'{{ group }}'{% if not loop.last %}, {% endif %}{% endfor %}])]
{% endif %}
    public ?string ${{ property.getPropertyName() }} = null;

{% endif %}
{% endif %}
{% endif %}
{% endfor %}

{% if entity.getCrossFieldValidationRules() %}
    /**
     * Cross-field validation rules
     */
    #[Assert\Callback]
    public function validateCrossFieldRules(ExecutionContextInterface $context): void
    {
{% for rule in entity.getCrossFieldValidationRules() %}
        // {{ rule.rule ?? 'Custom validation' }}
        // TODO: Implement cross-field validation logic
        // Example: if ($this->startDate > $this->endDate) { ... }
{% endfor %}
    }

{% endif %}
{% if entity.getUniqueConstraints() %}
    /**
     * Unique constraint validation
     * Note: This is validated at entity level, not DTO level
     */
{% for constraint in entity.getUniqueConstraints() %}
    // Unique: {{ constraint.fields|join(', ') }}
{% endfor %}

{% endif %}
{% if entity.getBusinessRules() %}
    /**
     * Business rule validation
     */
    #[Assert\Callback]
    public function validateBusinessRules(ExecutionContextInterface $context): void
    {
{% for rule in entity.getBusinessRules() %}
        // {{ rule.type ?? 'business' }}: {{ rule.rule ?? 'Custom rule' }}
        // TODO: Implement business rule validation
{% endfor %}
    }

{% endif %}
    // Getters and Setters
{% for property in entity.getProperties() %}
{% if property.getPropertyName() not in excludedProperties %}

    public function {{ getGetterName(property.getPropertyName()) }}(): {% if property.getRelationshipType() in ['OneToMany', 'ManyToMany'] and property.isDtoNestedEnabled() %}array{% elseif property.getRelationshipType() in ['ManyToOne', 'OneToOne'] %}?string{% else %}{% if property.isNullable() %}?{% endif %}{% if property.getPropertyType() == 'boolean' %}bool{% elseif property.getPropertyType() == 'integer' %}int{% elseif property.getPropertyType() == 'float' %}float{% elseif property.getPropertyType() == 'decimal' %}string{% elseif property.getPropertyType() in ['datetime', 'datetime_immutable', 'date', 'date_immutable'] %}\DateTimeImmutable{% elseif property.getPropertyType() == 'json' %}array{% else %}string{% endif %}{% endif %}
    {
        return $this->{{ property.getPropertyName() }};
    }

    public function {{ getSetterName(property.getPropertyName()) }}({% if property.getRelationshipType() in ['OneToMany', 'ManyToMany'] and property.isDtoNestedEnabled() %}array{% elseif property.getRelationshipType() in ['ManyToOne', 'OneToOne'] %}?string{% else %}{% if property.isNullable() %}?{% endif %}{% if property.getPropertyType() == 'boolean' %}bool{% elseif property.getPropertyType() == 'integer' %}int{% elseif property.getPropertyType() == 'float' %}float{% elseif property.getPropertyType() == 'decimal' %}string{% elseif property.getPropertyType() in ['datetime', 'datetime_immutable', 'date', 'date_immutable'] %}\DateTimeImmutable{% elseif property.getPropertyType() == 'json' %}array{% else %}string{% endif %}{% endif %} ${{ property.getPropertyName() }}): self
    {
        $this->{{ property.getPropertyName() }} = ${{ property.getPropertyName() }};
        return $this;
    }
{% endif %}
{% endfor %}
}
