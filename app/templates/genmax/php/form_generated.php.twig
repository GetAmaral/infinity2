<?php

declare(strict_types=1);

namespace {{ generatedNamespace }};

use App\Entity\{{ entityName }};
{% autoescape false %}
{% for import in formTypeImports %}
use {{ import }};
{% endfor %}
{% endautoescape %}
use Symfony\Contracts\Translation\TranslatorInterface;

/**
 * Generated Base Form for {{ entityName }}
 *
 * ⚠️ WARNING: This file is ALWAYS regenerated by Genmax
 * DO NOT EDIT THIS FILE - Edit {{ entityName }}Type instead
 *
 * @generated by Genmax
 * @codeCoverageIgnore
 */
abstract class {{ entityName }}TypeGenerated extends AbstractType
{
    public function __construct(
        protected readonly TranslatorInterface $translator
    ) {}

    public function buildForm(FormBuilderInterface $builder, array $options): void
    {
{% for field in formFields %}
{% if field.isParentBackReference %}
        // Conditionally exclude parent back-reference to prevent circular references in collections
        if (empty($options['exclude_parent'])) {
{% elseif field.type == 'CollectionType' %}
        // Exclude nested collections when form is used inside another collection
        if (empty($options['exclude_parent'])) {
{% endif %}
        $builder->add('{{ field.name }}', {{ field.type|raw }}::class, [
{% for key, value in field.options %}
{% if key == 'attr' or key == 'label_attr' or key == 'row_attr' %}
            '{{ key }}' => [
{% for attrKey, attrValue in value %}
                '{{ attrKey }}' => '{{ attrValue|e }}',
{% endfor %}
            ],
{% elseif key == 'entry_options' %}
            '{{ key }}' => [
{% for optKey, optValue in value %}
                '{{ optKey }}' => {{ optValue is same as(false) ? 'false' : (optValue is same as(true) ? 'true' : "'" ~ optValue|e ~ "'") }},
{% endfor %}
            ],
{% elseif key == 'constraints' and value is iterable %}
            '{{ key }}' => [
{% for constraint in value %}
                {{ constraint|raw }},
{% endfor %}
            ],
{% elseif value is same as(true) %}
            '{{ key }}' => true,
{% elseif value is same as(false) %}
            '{{ key }}' => false,
{% elseif value is same as(null) %}
            '{{ key }}' => null,
{% elseif key == 'class' %}
            '{{ key }}' => \{{ value|replace({'\\\\': '\\'}) }}::class,
{% elseif key == 'entry_type' %}
            '{{ key }}' => \{{ value|replace({'\\\\': '\\'}) }}::class,
{% elseif value is iterable %}
            '{{ key }}' => [
{% for arrKey, arrValue in value %}
                '{{ arrKey }}' => {% if arrValue is same as(true) %}true{% elseif arrValue is same as(false) %}false{% elseif arrValue is same as(null) %}null{% else %}'{{ arrValue|e }}'{% endif %},
{% endfor %}
            ],
{% else %}
            '{{ key }}' => '{{ value|e }}',
{% endif %}
{% endfor %}
        ]);
{% if field.isParentBackReference or field.type == 'CollectionType' %}
        }
{% endif %}

{% endfor %}
    }

    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'data_class' => {{ entityName|raw }}::class,
            'exclude_parent' => false,  // Set to true to exclude parent back-refs and nested collections (prevents circular refs)
        ]);
    }
}
